#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>  
#include <semaphore.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#define READ 0


#define WRITE 1

int main() {

    int file_descriptors[2];

    pid_t pid1,pid2,pid3;
    int i=0;
    char buf[256];
    char * input;
    int returned_count;
    
    char * sem_mutex_name="huchi";
    sem_t * mutex = sem_open(sem_mutex_name,O_CREAT | O_RDONLY,0666, 1);
     
     
    if(SEM_FAILED == mutex)
    {
      perror("sem_mutex_open error");
      return -1;
    }
    
    pipe(file_descriptors);  /*创建无名管道*/

    if((pid1 = fork()) == -1) { /*创建子进程*/
        printf("Error in fork\n");
        exit(1);
    }
    if(pid1 == 0) {
        
        
        sem_wait(mutex); 
        
        //        子进程向父进程写数据，关闭管道的读端
        close(file_descriptors[READ]);
       //input="111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n";
       input="pid1111111111111111111111111111111111111111111111111111111111111111111111111\n";
	 /*
	   input="11111111\n";
	    while (++i)
        {
            write(file_descriptors[WRITE], input, strlen(input));
            printf("pipe capacity: %d\n", (int)(i*(strlen(input))));
        }
	   */
	   
	   printf("pid1:%d is the child process...:%d\n",getpid(),(int)(strlen(input)));
	    write(file_descriptors[WRITE], input, strlen(input));
	    sem_post(mutex);
	    
        exit(0);
    }



    if ((pid2 = fork()) == -1) {
        printf("ERROR in fork pid2\n");
        exit(1);
    }
    if (pid2 == 0) {
       
        
        sem_wait(mutex); 
        
        input="pid2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222\n";
      //  input="pid22222222222222222222222222222222222222222222222222222222222222222222222222222222222\n";
        printf("pid2:%d is the child process...: %d\n",getpid(),(int)(strlen(input)));
		
		close(file_descriptors[READ]);
        write(file_descriptors[WRITE],input, strlen(input));
        sem_post(mutex);
        
        exit(0);
    }


    if ((pid3 = fork()) == -1) {
        printf("ERROR in fork pid3\n");
        exit(1);
    }
    if (pid3 == 0) {
        
        
        sem_wait(mutex); 
        
        input="pid333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333\n";
        printf("pid3:%d is the  child process which is writing...:%d\n",getpid(),(int)(strlen(input)));
		close(file_descriptors[READ]);
        write(file_descriptors[WRITE], input, strlen(input));
        sem_post(mutex);

        exit(0);
    }
    else {
        //        pid = wait(NULL);
        pid1 = waitpid(pid1, NULL, WUNTRACED);
        pid2 = waitpid(pid2, NULL, WUNTRACED);
        pid3 = waitpid(pid3, NULL, WUNTRACED);
        
        printf("parent process pid: %d\n",getpid());
        printf("wait pid: %d %d %d in the parent process...\n",pid1,pid2,pid3);
        /*父进程从管道读取子进程写的数据，关闭管道的写端*/
        close(file_descriptors[WRITE]);
        
        returned_count = (int)read(file_descriptors[READ], buf, sizeof(buf));
        while(returned_count){
        	printf("%d bytes of data received from child process: \n%s\n",returned_count, buf);
        	returned_count = (int)read(file_descriptors[READ], buf, sizeof(buf));
		}
        
    }
    return 0;
}
